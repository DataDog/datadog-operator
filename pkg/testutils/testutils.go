// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-2021 Datadog, Inc.

package testutils

import (
	"fmt"
	"reflect"

	corev1 "k8s.io/api/core/v1"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
)

var (
	diffHeader = "+ is content from test reference\n- is content generated by operator\n"
	k8sCmpOps  cmp.Options
)

func init() {
	sliceToMapTypes := map[reflect.Type]struct{}{
		reflect.TypeOf([]corev1.EnvVar{}):      {},
		reflect.TypeOf([]corev1.Volume{}):      {},
		reflect.TypeOf([]corev1.VolumeMount{}): {},
		reflect.TypeOf([]corev1.Container{}):   {},
	}

	sliceToMapFilterFunc := func(x interface{}, y interface{}) bool {
		xType := reflect.TypeOf(x)
		yType := reflect.TypeOf(y)

		if _, found := sliceToMapTypes[xType]; !found {
			return false
		}

		if _, found := sliceToMapTypes[yType]; !found {
			return false
		}

		return true
	}

	sliceToMapFunc := func(x interface{}) interface{} {
		xVal := reflect.ValueOf(x)
		res := make(map[string]interface{}, xVal.Len())
		for i := 0; i < xVal.Len(); i++ {
			elemVal := xVal.Index(i)
			res[elemVal.FieldByName("Name").String()] = elemVal.Interface()
		}

		return res
	}

	k8sCmpOps = append(k8sCmpOps, cmp.Transformer("", func(x []corev1.EnvVar) interface{} { return sliceToMapFunc(x) }))
	k8sCmpOps = append(k8sCmpOps, cmp.Transformer("", func(x []corev1.Volume) interface{} { return sliceToMapFunc(x) }))
	k8sCmpOps = append(k8sCmpOps, cmp.Transformer("", func(x []corev1.VolumeMount) interface{} { return sliceToMapFunc(x) }))
	k8sCmpOps = append(k8sCmpOps, cmp.Transformer("", func(x []corev1.Container) interface{} { return sliceToMapFunc(x) }))
	k8sCmpOps = append(k8sCmpOps, cmp.FilterValues(func(x interface{}, y interface{}) bool {
		return !sliceToMapFilterFunc(x, y)
	}, cmpopts.SortSlices(func(x, y interface{}) bool {
		xVal := reflect.ValueOf(x)
		yVal := reflect.ValueOf(y)
		if xVal.Kind() == reflect.Struct && xVal.FieldByName("Name").IsValid() {
			return xVal.FieldByName("Name").String() < yVal.FieldByName("Name").String()
		}

		return fmt.Sprintf("%v", x) < fmt.Sprintf("%v", y)
	})))
}

// CompareKubeResource performs a Diff based cmp.Diff() with some options
func CompareKubeResource(got, want interface{}) string {
	diff := cmp.Diff(got, want, k8sCmpOps...)
	if len(diff) > 0 {
		diff = diffHeader + diff
	}

	return diff
}
