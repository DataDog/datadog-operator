// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package datadogagent

import (
	"context"

	"github.com/go-logr/logr"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/util/errors"

	"github.com/DataDog/datadog-operator/api/datadoghq/v2alpha1"
	"github.com/DataDog/datadog-operator/internal/controller/datadogagent/common"
	"github.com/DataDog/datadog-operator/internal/controller/datadogagent/component/clusteragent"
	"github.com/DataDog/datadog-operator/internal/controller/datadogagent/feature"
	"github.com/DataDog/datadog-operator/internal/controller/datadogagent/global"
	"github.com/DataDog/datadog-operator/internal/controller/datadogagent/store"
	"github.com/DataDog/datadog-operator/pkg/kubernetes"
	"github.com/DataDog/datadog-operator/pkg/secrets"
)

// setupDDADependenciesStore initializes a store specifically for DDA controller dependencies
// when DatadogAgentInternalEnabled is true. The store is marked with IsDDAControllerStore
// so that resources created by it are labeled and won't be cleaned up by the DDAI controller.
func (r *Reconciler) setupDDADependenciesStore(instance *v2alpha1.DatadogAgent, logger logr.Logger) (*store.Store, feature.ResourceManagers) {
	storeOptions := &store.StoreOptions{
		SupportCilium:        r.options.SupportCilium,
		PlatformInfo:         r.platformInfo,
		Logger:               logger,
		Scheme:               r.scheme,
		IsDDAControllerStore: true,
	}
	depsStore := store.NewStore(instance, storeOptions)
	resourceManagers := feature.NewResourceManagers(depsStore)
	return depsStore, resourceManagers
}

func (r *Reconciler) manageDDADependenciesWithDDAI(ctx context.Context, logger logr.Logger, instance *v2alpha1.DatadogAgent, newDDAStatus *v2alpha1.DatadogAgentStatus) error {
	// Use a store marked as DDA controller store so resources are labeled
	// with ManagedByDDAControllerLabelKey and won't be cleaned up by DDAI controller.
	depsStore, resourceManagers := r.setupDDADependenciesStore(instance, logger)

	// Credentials
	if err := global.AddCredentialDependencies(logger, instance.GetObjectMeta(), &instance.Spec, resourceManagers); err != nil {
		return err
	}

	// Install info
	if err := global.AddInstallInfoDependencies(instance, resourceManagers); err != nil {
		return err
	}

	// DCA token
	if err := global.AddDCATokenDependencies(logger, instance.GetObjectMeta(), &instance.Spec, &instance.Status, resourceManagers); err != nil {
		return err
	}
	ensureAutoGeneratedTokenInStatus(instance, newDDAStatus, resourceManagers, logger)

	// APM Telemetry
	// ConfigMap stores DatadogAgent resource UID and creation time whether or not DatadogAgentInternal is enabled.
	if err := global.AddAPMTelemetryDependencies(logger, instance, resourceManagers); err != nil {
		return err
	}

	// DCA service
	service := clusteragent.GetClusterAgentService(instance)
	if err := resourceManagers.ServiceManager().AddService(service.Name, service.Namespace, service.Spec.Selector, service.Spec.Ports, service.Spec.InternalTrafficPolicy); err != nil {
		return err
	}

	// Apply dependencies
	if err := depsStore.Apply(ctx, r.client); err != nil {
		return errors.NewAggregate(err)
	}

	// Cleanup unused DDA controller dependencies.
	// Pass false since we want to clean up DDA-managed resources (this is the DDA controller).
	// Note that we don't really need to clean these dependencies as they're all ownerRef'ed by the DDA, so they will be cleaned if the DDA is deleted.
	if err := depsStore.Cleanup(ctx, r.client, false); err != nil {
		return errors.NewAggregate(err)
	}

	return nil
}

func ensureAutoGeneratedTokenInStatus(instance *v2alpha1.DatadogAgent, newStatus *v2alpha1.DatadogAgentStatus, resourceManagers feature.ResourceManagers, logger logr.Logger) {
	if instance.Status.ClusterAgent != nil && instance.Status.ClusterAgent.GeneratedToken != "" {
		// Already there; nothing to do.
		return
	}

	tokenSecret, exists := resourceManagers.Store().Get(
		kubernetes.SecretsKind, instance.Namespace, secrets.GetDefaultDCATokenSecretName(instance),
	)
	if !exists {
		logger.V(1).Info("expected autogenerated token was not created by global dependencies")
		return
	}

	generatedToken := tokenSecret.(*corev1.Secret).Data[common.DefaultTokenKey]
	if newStatus == nil {
		newStatus = &v2alpha1.DatadogAgentStatus{}
	}
	if newStatus.ClusterAgent == nil {
		newStatus.ClusterAgent = &v2alpha1.DeploymentStatus{}
	}
	// Persist generated token for subsequent reconcile loops
	newStatus.ClusterAgent.GeneratedToken = string(generatedToken)
}
